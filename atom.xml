<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Max的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-19T16:10:42.509Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Max Qi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/07/20/%E7%9C%8B%E4%BA%86%E4%B8%80%E7%82%B9zookeeper%E7%9A%84%E5%BF%83%E5%BE%97/"/>
    <id>http://yoursite.com/2018/07/20/看了一点zookeeper的心得/</id>
    <published>2018-07-19T16:10:42.509Z</published>
    <updated>2018-07-19T16:10:42.509Z</updated>
    
    <content type="html"><![CDATA[<p>###Fast Paxos算法：</p><p>###文件结构：</p><p>zookeeper的文件结构大概是这个样子的：</p><p>!å¾ 1 Zookeeper æ°æ®ç”æ](<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/image001.gif" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/image001.gif</a>)</p><h3 id="znode（data-node）："><a href="#znode（data-node）：" class="headerlink" title="znode（data node）："></a>znode（data node）：</h3><ol><li>其中的每个子目录就是一个znode，他们也可以有子的znode（临时znode除外）。</li><li>这些znode必须是绝对路径，不允许相对路径。</li><li>每个znode都维护一个stat structure（linux系统文件的结构），其中包括版本号，acl改变等等。每次更新数据会让版本号自增。</li><li>每个znode可以设置一个watches，当watch触发后，zookeeper将发给client一个提醒。</li><li>在znode中数据读写是原子性的。每个znode都有一个ACL（access control list）来控制其读写权限。zookeeper不是用来做数据库的，其中存储的数据可能都是几kb的配置/状态信息。大块数据都存在hdfs中。</li><li>Ephemeral node就是临时节点，每次会话结束这些节点都会清空，不允许有子节点。</li></ol><p>###Zookeeper Session：</p><p><img src="/Users/max/Documents/Blog/source/img/state_dia.jpg" alt="state_dia"></p><p>###一致性的保证：</p><p>zookeeper是一个非常高效、可扩展的服务。其一致性靠以下几点保证：</p><ol><li>顺序的一致性。一个client的更新会依序发送给其他。</li><li>原子性。更新是原子操作，只有成功和失败，没有中间过程。</li><li>服务器会看到完全相同的服务，不论其连接了哪个服务器。</li><li>可靠性。一旦一个更新被部署，他会一直存在，直到被另一个更新覆盖。</li><li>及时性。client对系统的观察在一个时间段内将是最新的。也即系统的改变在这个时间段内client是看见的，或者可以探测到它失败。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###Fast Paxos算法：&lt;/p&gt;
&lt;p&gt;###文件结构：&lt;/p&gt;
&lt;p&gt;zookeeper的文件结构大概是这个样子的：&lt;/p&gt;
&lt;p&gt;!å¾ 1 Zookeeper æ°æ®ç”æ](&lt;a href=&quot;https://www.ibm.com/develo
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从numpy入手</title>
    <link href="http://yoursite.com/2018/07/18/%E4%BB%8Enumpy%E5%85%A5%E6%89%8B/"/>
    <id>http://yoursite.com/2018/07/18/从numpy入手/</id>
    <published>2018-07-18T02:26:21.042Z</published>
    <updated>2018-07-21T09:44:42.096Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了一些numpy的基础，在这里整理一下。</p><h3 id="创建："><a href="#创建：" class="headerlink" title="创建："></a>创建：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#数组</span></span><br><span class="line">array1 = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">np.eye(<span class="number">3</span>)<span class="comment">#单位多维数组</span></span><br><span class="line">np.diag([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])<span class="comment">#对角多维数组</span></span><br><span class="line">np.arange(<span class="number">1</span>,<span class="number">4</span>)<span class="comment">#[1,2,3]数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#矩阵</span></span><br><span class="line">np.mat(<span class="string">"1 2 3;4 5 6;7 8 9"</span>)<span class="comment">#矩阵运算与多维数组运算结果不同，所以要用mat建矩阵，用分号隔开数据</span></span><br><span class="line">matrix = np.mat(array1)<span class="comment">#可以用多维数组初始化矩阵</span></span><br><span class="line">matrix1 = np.bmat(<span class="string">"array1 array2;array1 array2"</span>)<span class="comment">#创建分块矩阵</span></span><br></pre></td></tr></table></figure><h3 id="随机数："><a href="#随机数：" class="headerlink" title="随机数："></a>随机数：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.random.random(<span class="number">100</span>)<span class="comment">#完全随机</span></span><br><span class="line">np.random.rand(<span class="number">5</span>,<span class="number">5</span>)<span class="comment">#5*5均匀分布</span></span><br><span class="line">np.random.randn(<span class="number">5</span>,<span class="number">5</span>)<span class="comment">#5*5正态分布</span></span><br><span class="line">np.random.randint(<span class="number">2</span>,<span class="number">50</span>,size=(<span class="number">2</span>,<span class="number">3</span>),dtype=<span class="string">'l'</span>)<span class="comment">#大于等于2小于50的2*3的int64型整数</span></span><br></pre></td></tr></table></figure><h3 id="变换数组形态："><a href="#变换数组形态：" class="headerlink" title="变换数组形态："></a>变换数组形态：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.reshape(<span class="number">3</span>,<span class="number">3</span>)<span class="comment">#转变成3*3的数组，但要求原数组必须9个元素，否则不能reshape</span></span><br><span class="line">np.hstack((arr1,arr2))<span class="comment">#横向组合</span></span><br><span class="line">np.vsplit(arr4,<span class="number">3</span>)<span class="comment">#横向切割，即把横向由1列的变成3列（相当于横着切）</span></span><br></pre></td></tr></table></figure><h3 id="文件存储与读取"><a href="#文件存储与读取" class="headerlink" title="文件存储与读取"></a>文件存储与读取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#二进制存储与读取</span></span><br><span class="line"><span class="comment">#存储</span></span><br><span class="line">file = <span class="string">"./temp/save_arr.npy"</span></span><br><span class="line">filez = <span class="string">"./temp/save_arr.npz"</span></span><br><span class="line">np.save(file,arr)<span class="comment">#用save存，文件扩展名.npy，只能存一个数组</span></span><br><span class="line">np.savez(filez,arr1[,arr2...])<span class="comment">#用savez存，文件扩展名.npz，可以存多个数组。注意：不按照要求扩展名，则系统自己添加对应扩展名；二进制存储的数组打开文件看不到真实数据</span></span><br><span class="line"><span class="comment">#读取</span></span><br><span class="line">loaded_data = np.load(file)<span class="comment">#存储可以省略扩展名，读取一定不可以</span></span><br><span class="line">loaded_dataz = np.load(filez)</span><br><span class="line">loaded_dataz[<span class="string">"arr_0"</span>]<span class="comment">#对于多个文件读取，这种方式可以得到单独数组</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件存储与读取</span></span><br><span class="line"><span class="comment">#存储</span></span><br><span class="line">np.savetxt(fname,x,fmt=<span class="string">'%d'</span>,delimiter=<span class="string">','</span>,newline=<span class="string">'\n'</span>,header=<span class="string">''</span>,footer=<span class="string">''</span>,comments=<span class="string">'# '</span>)<span class="comment">#x为要存的数组，fmt='%d'表示整数方式存，delimiter表示存储时的分隔符，存储和读取时默认为空格</span></span><br><span class="line"><span class="comment">#读取</span></span><br><span class="line">loaded_data = np.loadtxt(fname,delimiter=<span class="string">","</span>)<span class="comment">#一定也要带上啊delimiter且与文件中的分隔符一致</span></span><br></pre></td></tr></table></figure><h3 id="利用numpy做简单的统计分析"><a href="#利用numpy做简单的统计分析" class="headerlink" title="利用numpy做简单的统计分析"></a>利用numpy做简单的统计分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">10</span>)<span class="comment">#种子是伪随机数的开头，相同种子对应随机数都相同，一般种子会设为当前时间，确保得到真随机数（numpy默认也是这样）</span></span><br><span class="line">arr = np.random.randint(<span class="number">1</span>,<span class="number">10</span>,size=<span class="number">10</span>)</span><br><span class="line"><span class="comment">#排序</span></span><br><span class="line">arr.sort()<span class="comment">#这个会直接将arr排序</span></span><br><span class="line">arr.sort(axis=<span class="number">0</span>)<span class="comment">#二维数组的sort参数axis可以为0、1，分别对应数组纵向和横向的排序</span></span><br><span class="line"><span class="comment">#去重</span></span><br><span class="line">np.unique(arr)</span><br><span class="line"><span class="comment">#重复</span></span><br><span class="line">np.tile(arr,<span class="number">3</span>)<span class="comment">#arr是重复哪个，3是重复次数</span></span><br><span class="line">np.repeat(arr,<span class="number">3</span>,axis=<span class="number">0</span>)<span class="comment">#axis是重复的方向（tile没有这个参数）</span></span><br><span class="line"><span class="comment">#注意：tile是对数组进行重复，repeat则是对每一个数组的每一个元素进行重复，打破了原来的数组。</span></span><br><span class="line"><span class="comment">#常用统计函数</span></span><br><span class="line">np.sum(arr)<span class="comment">#求和</span></span><br><span class="line">arr.sum(axis=<span class="number">0</span>)<span class="comment">#沿纵轴求和</span></span><br><span class="line">np.mean(arr)<span class="comment">#计算数组均值</span></span><br><span class="line">arr.mean(axis = <span class="number">0</span>)<span class="comment">#沿着纵轴计算数组均值</span></span><br><span class="line">np.std(arr)<span class="comment">#计算标准差</span></span><br><span class="line">np.var(arr)<span class="comment">#计算方差</span></span><br><span class="line">np.min(arr)<span class="comment">#计算最小值</span></span><br><span class="line">np.max(arr)<span class="comment">#计算最大值</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近看了一些numpy的基础，在这里整理一下。&lt;/p&gt;
&lt;h3 id=&quot;创建：&quot;&gt;&lt;a href=&quot;#创建：&quot; class=&quot;headerlink&quot; title=&quot;创建：&quot;&gt;&lt;/a&gt;创建：&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;tabl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>最近在看的东西</title>
    <link href="http://yoursite.com/2018/07/16/20180716%E6%97%A5%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/07/16/20180716日记/</id>
    <published>2018-07-16T09:12:39.376Z</published>
    <updated>2018-07-16T09:12:39.377Z</updated>
    
    <content type="html"><![CDATA[<p>最近都没有写博客，想更一篇了。</p><p>前几天在刷算法，这几天看了一些springboot的东西。之前对spring了解的也比较多，而且这次看的也比较浅，就这样吧。</p><p>感觉很慌。马上要找工作了，我却还没开始工作…</p><p>spring-boot用的时候再看吧，</p><p>算法还是要接着刷，</p><p>接下来就做我的python了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近都没有写博客，想更一篇了。&lt;/p&gt;
&lt;p&gt;前几天在刷算法，这几天看了一些springboot的东西。之前对spring了解的也比较多，而且这次看的也比较浅，就这样吧。&lt;/p&gt;
&lt;p&gt;感觉很慌。马上要找工作了，我却还没开始工作…&lt;/p&gt;
&lt;p&gt;spring-boot用的时
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>anaconda基础</title>
    <link href="http://yoursite.com/2018/07/04/%E6%96%B0%E7%9A%84%E5%B0%9D%E8%AF%95/"/>
    <id>http://yoursite.com/2018/07/04/新的尝试/</id>
    <published>2018-07-04T12:20:26.782Z</published>
    <updated>2018-07-21T15:02:20.339Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个python环境、包管理工具，这玩意很厉害。</p><h3 id="插一个其他东西："><a href="#插一个其他东西：" class="headerlink" title="插一个其他东西："></a>插一个其他东西：</h3><p>在搞conda环境变量的时候在.zshrc里没有注意语句的顺序，变量使用在前，声明在后，导致path里没有这个。。。。。。以后要注意了！</p><p>###使用原因：</p><ol><li>和以前用的virtualenv有点像，可以创建一个独立的python环境，python版本，包都是独立于外部的。</li><li>自带很多数据科学的包，省的下。</li><li>可以将环境与远程同步，也可以clone别人的环境，开发效率高。</li><li>可以与pycharm等工具结合，通用性强。</li><li>Anaconda navigator是一个桌面应用，使用非常简单。</li></ol><p>###常用到的操作：</p><ol><li>在命令行可以用conda来操作一些东西：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">conda create -n &lt;env-name&gt; &lt;package-name&gt;<span class="comment">#创建conda环境</span></span><br><span class="line"></span><br><span class="line">conda remove -n &lt;env-name&gt;<span class="comment">#删除conda环境</span></span><br><span class="line"></span><br><span class="line">conda env list<span class="comment">#查看所有环境，其中带*的为当前环境，在当前环境下，用的python版本、包等都是anaconda的，而不是本机环境</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> activate &lt;env-name&gt;<span class="comment">#激活某个环境，之后zsh前面会加上这个环境的名称</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> deactivate<span class="comment">#退出某个环境</span></span><br><span class="line"></span><br><span class="line">conda install &lt;package-name&gt;[=versionInfo]<span class="comment">#在当前环境下安装包，可以选定版本</span></span><br><span class="line"></span><br><span class="line">conda install -n &lt;env-name&gt; &lt;package-name&gt;<span class="comment">#在特定环境中</span></span><br><span class="line"></span><br><span class="line">conda list<span class="comment">#列出当前环境所有的包</span></span><br><span class="line"></span><br><span class="line">conda search &lt;package-name&gt;<span class="comment">#查找某个包（模糊匹配）</span></span><br></pre></td></tr></table></figure><p>###conda和pycharm的结合：</p><p>pycharm可以直接用conda的environment来做，只要在选择interpreter的时候选conda环境对应的那个即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一个python环境、包管理工具，这玩意很厉害。&lt;/p&gt;
&lt;h3 id=&quot;插一个其他东西：&quot;&gt;&lt;a href=&quot;#插一个其他东西：&quot; class=&quot;headerlink&quot; title=&quot;插一个其他东西：&quot;&gt;&lt;/a&gt;插一个其他东西：&lt;/h3&gt;&lt;p&gt;在搞conda环境变量的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一些简单的命令行操作总结</title>
    <link href="http://yoursite.com/2018/07/04/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/07/04/一些简单的命令行操作总结/</id>
    <published>2018-07-04T10:03:57.407Z</published>
    <updated>2018-07-04T10:03:57.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些简单的命令行操作总结"><a href="#一些简单的命令行操作总结" class="headerlink" title="一些简单的命令行操作总结"></a>一些简单的命令行操作总结</h1><p>今天看了一些oh-my-zsh的东西，感觉还是要整理在博客中，不然太容易忘掉了。</p><ol><li>一些好用的插件，z/web-search/d/zsh-autosuggestions</li><li>很常用的一些命令行快捷键 如ctrl+q/w/e/a</li><li>conda的随后再说</li><li>ssh的key的名字问题</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一些简单的命令行操作总结&quot;&gt;&lt;a href=&quot;#一些简单的命令行操作总结&quot; class=&quot;headerlink&quot; title=&quot;一些简单的命令行操作总结&quot;&gt;&lt;/a&gt;一些简单的命令行操作总结&lt;/h1&gt;&lt;p&gt;今天看了一些oh-my-zsh的东西，感觉还是要整理在博客中
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Cryptocurrency Technologies</title>
    <link href="http://yoursite.com/2018/04/30/Cryptocurrency%20Technologies/"/>
    <id>http://yoursite.com/2018/04/30/Cryptocurrency Technologies/</id>
    <published>2018-04-30T08:27:54.000Z</published>
    <updated>2018-07-04T12:02:09.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cryptocurrency-Technologies"><a href="#Cryptocurrency-Technologies" class="headerlink" title="Cryptocurrency Technologies"></a>Cryptocurrency Technologies</h1><p>Coursera course from Princeton University, here are some information and notes from the course.</p><hr><h2 id="Cryptographic-Hash-Functions"><a href="#Cryptographic-Hash-Functions" class="headerlink" title="Cryptographic Hash Functions"></a>Cryptographic Hash Functions</h2><p>Hash function :</p><ul><li>takes any string of any size as input</li><li>fixed-size output (We’ll use 256 bits )</li><li>efficiently computable</li></ul><p>Security properties:</p><ul><li>collision-free</li><li>hiding</li><li>puzzle-friendly </li></ul><h3 id="collision-free"><a href="#collision-free" class="headerlink" title="collision-free"></a>collision-free</h3><h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>Nobody can find x and y such that:</p><blockquote><p> <strong>x!=y and H(x) = H(y)</strong>  </p></blockquote><p>So that is what we call collision-free.</p><p>Actually <strong>collision do exist. But it merely be found</strong> ——that is guaranteed the work.</p><h4 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h4><p>If we know H(x) = H(y), it’s safe to assume that x = y. Hash function provide us with a efficient way to recognize the same things. The hash is small, which has only 256 bits, while the whole things might be really big.</p><h3 id="Hiding"><a href="#Hiding" class="headerlink" title="Hiding"></a>Hiding</h3><h4 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h4><p>We want something like this:</p><blockquote><p>Given H(x), it is infeasible to find x.</p></blockquote><p>high min-entropy : the distribution is “very spread out”. If r is chosen from a probability distribution that has high min-entropy, then given H(r | x), it is infeasible to find x.</p><h4 id="Application-Commitment"><a href="#Application-Commitment" class="headerlink" title="Application : Commitment"></a>Application : Commitment</h4><p>Commit to a value, reveal it later.</p><blockquote><p><strong>com = H(key | msg)</strong></p></blockquote><h5 id="Hidding"><a href="#Hidding" class="headerlink" title="Hidding:"></a>Hidding:</h5><p>Given H(key | msg), infeasible to find msg.</p><h5 id="Binding"><a href="#Binding" class="headerlink" title="Binding:"></a>Binding:</h5><p>Infeasible to find msg != msg’ such that H(key | msg) == H(key | msg’)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Cryptocurrency-Technologies&quot;&gt;&lt;a href=&quot;#Cryptocurrency-Technologies&quot; class=&quot;headerlink&quot; title=&quot;Cryptocurrency Technologies&quot;&gt;&lt;/a&gt;Crypt
      
    
    </summary>
    
    
  </entry>
  
</feed>
